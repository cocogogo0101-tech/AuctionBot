# ====================================================================
# AUCTIONBOT v3.0 - COMPLETE CODE BUNDLE
# ====================================================================
# Ø§Ù„Ù…Ø·ÙˆØ±: Ø¯Ø§Ø±Ùƒ
# Ø§Ù„Ø³ÙŠØ±ÙØ±: Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ©
# Ø§Ù„Ù†Ø³Ø®Ø©: 3.0.0 Railway Edition
# ====================================================================
#
# Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù ÙŠØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£ÙƒÙˆØ§Ø¯ Ù…Ø¬Ù…Ø¹Ø© ÙÙŠ Ù…ÙƒØ§Ù† ÙˆØ§Ø­Ø¯
# Ù„Ù„Ù…Ø±Ø¬Ø¹ÙŠØ© ÙˆØ§Ù„Ù†Ø³Ø® Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ
#
# ====================================================================

# ====================================================================
# FILE: bot.py
# ====================================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ”¥ AuctionBot - Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ©
Ø¨ÙˆØª Ù…Ø²Ø§Ø¯Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠ Ù…Ø¹ Ø­Ù…Ø§ÙŠØ© ÙƒØ§Ù…Ù„Ø© ÙˆÙ†Ø¸Ø§Ù… Self-Healing

Ø§Ù„Ù…Ø·ÙˆØ±: Ø¯Ø§Ø±Ùƒ
Ø§Ù„Ù†Ø³Ø®Ø©: 3.0.0 (Railway Edition)
"""

import os
import sys
import asyncio
import logging
import traceback
import time
import csv
from datetime import datetime, timezone, timedelta
from io import StringIO
from typing import Optional

import discord
from discord import app_commands
from discord.ext import commands
from discord.ui import View, Button, Modal, TextInput
from dotenv import load_dotenv

# Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
import db

# ==================== ğŸ”§ CONFIGURATION ====================

# ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ¦Ø©
load_dotenv()

# ğŸ›¡ï¸ Ù…Ø¹Ø§Ù„Ø¬Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ù„Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
def clean_env(var_name: str) -> str:
    """ØªÙ†Ø¸ÙŠÙ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø© Ù…Ù† Ø§Ù„Ù…Ø³Ø§ÙØ§Øª ÙˆØ§Ù„Ø£Ø³Ø·Ø± Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©"""
    value = os.getenv(var_name, "")
    if value:
        value = value.strip()
        value = value.replace('\\n', '').replace('\\r', '')
        value = value.replace('"', '').replace("'", '')
    return value

# Ø¬Ù„Ø¨ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ù…Ø¹ Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
TOKEN = clean_env("DISCORD_TOKEN")
DATABASE_URL = clean_env("DATA")
ALLOWED_GUILD_ID = clean_env("ALLOWED_GUILD_ID")

# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
if not TOKEN:
    print("âŒ CRITICAL ERROR: DISCORD_TOKEN is missing!")
    sys.exit(1)

if not DATABASE_URL:
    print("âŒ CRITICAL ERROR: DATA (Database URL) is missing!")
    sys.exit(1)

# ØªØ­ÙˆÙŠÙ„ ALLOWED_GUILD_ID Ø¥Ù„Ù‰ Ø±Ù‚Ù…
if ALLOWED_GUILD_ID:
    try:
        ALLOWED_GUILD_ID = int(ALLOWED_GUILD_ID)
    except:
        ALLOWED_GUILD_ID = None

# ==================== ğŸ“Š LOGGING SETUP ====================

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('bot.log', encoding='utf-8')
    ]
)
logger = logging.getLogger('AuctionBot')

# ==================== ğŸ¯ BOT SETUP ====================

intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True

bot = commands.Bot(
    command_prefix="!",
    intents=intents,
    help_command=None,
    heartbeat_timeout=60.0
)
tree = bot.tree

# ==================== ğŸ’¾ IN-MEMORY STORAGE ====================

AUCTIONS = {}

class Auction:
    def __init__(self, guild_id: int, channel_id: int, message_id: int, db_id: int,
                 start_price: int, min_increase: int, end_time: float, created_by: int):
        self.guild_id = guild_id
        self.channel_id = channel_id
        self.message_id = message_id
        self.db_id = db_id
        self.start_price = start_price
        self.current_price = start_price
        self.min_increase = min_increase
        self.end_time = end_time
        self.created_by = created_by
        self.highest_bidder = None
        self.bids = []
        self.ended = False
        self.cancelled = False
        self.start_time = asyncio.get_event_loop().time()

    def to_log_embed(self, guild_name: str) -> discord.Embed:
        if self.cancelled:
            embed = discord.Embed(title="ğŸš« ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø²Ø§Ø¯ - ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡", color=0xe74c3c)
        else:
            embed = discord.Embed(title="ğŸ“œ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ù…Ø²Ø§Ø¯ Ø§Ù„ÙƒØ§Ù…Ù„", color=0x2F3136)
        
        embed.add_field(name="Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±", value=guild_name, inline=False)
        
        start_dt = datetime.fromtimestamp(self.start_time, tz=timezone.utc)
        end_dt = datetime.fromtimestamp(self.end_time, tz=timezone.utc)
        embed.add_field(name="Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù…Ø²Ø§Ø¯", value=start_dt.strftime("%Y-%m-%d %H:%M UTC"), inline=True)
        embed.add_field(name="Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø²Ø§Ø¯", value=end_dt.strftime("%Y-%m-%d %H:%M UTC"), inline=True)
        
        if self.bids:
            text = ""
            for i, bid in enumerate(self.bids[-10:], start=1):
                t_iso, uid, amt = bid
                text += f"{i}. <@{uid}> â€” **{fmt_amount(amt)}**\\n"
            embed.add_field(name="ğŸ“‹ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø²Ø§ÙŠØ¯Ø§Øª", value=text or "Ù„Ø§ ØªÙˆØ¬Ø¯", inline=False)
        
        participants = len(set([b[1] for b in self.bids]))
        embed.add_field(
            name="ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª",
            value=f"Ø§Ù„Ù…Ø²Ø§ÙŠØ¯Ø§Øª: {len(self.bids)} | Ø§Ù„Ù…Ø´Ø§Ø±ÙƒÙŠÙ†: {participants}",
            inline=False
        )
        
        if self.cancelled:
            embed.add_field(
                name="ğŸš« Ø§Ù„Ù†ØªÙŠØ¬Ø©",
                value=f"**ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡**\\nØ¢Ø®Ø± Ø³Ø¹Ø±: **{fmt_amount(self.current_price)}**",
                inline=False
            )
        else:
            winner = f"<@{self.highest_bidder}>" if self.highest_bidder else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
            embed.add_field(
                name="ğŸ† Ø§Ù„Ù†ØªÙŠØ¬Ø©",
                value=f"Ø§Ù„ÙØ§Ø¦Ø²: {winner}\\nØ§Ù„Ù…Ø¨Ù„Øº: **{fmt_amount(self.current_price)}**",
                inline=False
            )
        
        embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
        return embed

# ==================== ğŸ”§ HELPER FUNCTIONS ====================

def parse_amount(text: str) -> int:
    if not text:
        return 0
    s = str(text).strip().lower().replace(",", "")
    try:
        if s.isdigit():
            return int(s)
        if s.endswith("k"):
            return int(float(s[:-1]) * 1000)
        if s.endswith("m"):
            return int(float(s[:-1]) * 1000000)
        return int(float(s))
    except:
        return 0

def fmt_amount(n: int) -> str:
    if not n:
        return "0"
    if n >= 1_000_000:
        v = n / 1_000_000
        return f"{int(v)}m" if v.is_integer() else f"{v:.2f}m"
    if n >= 1_000:
        v = n / 1_000
        return f"{int(v)}k" if v.is_integer() else f"{v:.1f}k"
    return f"{n:,}"

# ==================== ğŸ¨ UI COMPONENTS ====================

class BidModal(Modal, title="Ø§ÙƒØªØ¨ Ø§Ù„Ù…Ø¨Ù„Øº"):
    amount = TextInput(
        label="Ø§Ù„Ù…Ø¨Ù„Øº (Ù…Ø«Ø§Ù„: 100k Ø£Ùˆ 1m)",
        placeholder="Ù…Ø«Ø§Ù„: 500k",
        required=True,
        max_length=20
    )

    def __init__(self, auction_message_id: int):
        super().__init__()
        self.auction_message_id = auction_message_id

    async def on_submit(self, interaction: discord.Interaction):
        amt = parse_amount(self.amount.value)
        auction = AUCTIONS.get(self.auction_message_id)
        
        if not auction or auction.ended or auction.cancelled:
            await interaction.response.send_message("âŒ Ø§Ù„Ù…Ø²Ø§Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­ Ø§Ù„Ø¢Ù†", ephemeral=True)
            return
        
        if interaction.user.bot:
            await interaction.response.send_message("âŒ Ø§Ù„Ø¨ÙˆØªØ§Øª ØºÙŠØ± Ù…Ø³Ù…ÙˆØ­ Ù„Ù‡Ø§ Ø¨Ø§Ù„Ù…Ø²Ø§ÙŠØ¯Ø©", ephemeral=True)
            return
        
        min_needed = auction.current_price + auction.min_increase
        if amt < min_needed:
            await interaction.response.send_message(
                f"âŒ Ø§Ù„Ù…Ø¨Ù„Øº Ø£Ù‚Ù„ Ù…Ù† Ø§Ù„Ù…Ø·Ù„ÙˆØ¨\\nØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰: **{fmt_amount(min_needed)}**",
                ephemeral=True
            )
            return
        
        auction.current_price = amt
        auction.highest_bidder = interaction.user.id
        ts = datetime.now(timezone.utc).isoformat()
        auction.bids.append((ts, interaction.user.id, amt))
        
        try:
            await db.insert_bid(auction.db_id, interaction.user.id, amt)
        except Exception as e:
            logger.error(f"Error saving bid: {e}")
        
        await update_auction_message(auction)
        
        await interaction.response.send_message(
            f"âœ… ØªÙ…Øª Ù…Ø²Ø§ÙŠØ¯ØªÙƒ Ø¨Ù…Ø¨Ù„Øº **{fmt_amount(amt)}** Ø¨Ù†Ø¬Ø§Ø­!",
            ephemeral=True
        )

class AuctionView(View):
    def __init__(self, auction_message_id: int):
        super().__init__(timeout=None)
        self.auction_message_id = auction_message_id

    @discord.ui.button(label="Ø²Ø§ÙŠØ¯ +", style=discord.ButtonStyle.primary, custom_id="quick_bid")
    async def quick_bid(self, interaction: discord.Interaction, button: Button):
        auction = AUCTIONS.get(self.auction_message_id)
        
        if not auction or auction.ended or auction.cancelled:
            await interaction.response.send_message("âŒ Ø§Ù„Ù…Ø²Ø§Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­", ephemeral=True)
            return
        
        amt = auction.current_price + auction.min_increase
        auction.current_price = amt
        auction.highest_bidder = interaction.user.id
        ts = datetime.now(timezone.utc).isoformat()
        auction.bids.append((ts, interaction.user.id, amt))
        
        try:
            await db.insert_bid(auction.db_id, interaction.user.id, amt)
        except Exception as e:
            logger.error(f"Error saving bid: {e}")
        
        await update_auction_message(auction)
        
        await interaction.response.send_message(
            f"âœ… ØªÙ…Øª Ù…Ø²Ø§ÙŠØ¯ØªÙƒ Ø¨Ù…Ø¨Ù„Øº **{fmt_amount(amt)}**",
            ephemeral=True
        )

    @discord.ui.button(label="Ù…Ø¨Ù„Øº Ù…Ø®ØµÙ‘Øµ", style=discord.ButtonStyle.secondary, custom_id="custom_bid")
    async def custom_bid(self, interaction: discord.Interaction, button: Button):
        auction = AUCTIONS.get(self.auction_message_id)
        
        if not auction or auction.ended or auction.cancelled:
            await interaction.response.send_message("âŒ Ø§Ù„Ù…Ø²Ø§Ø¯ ØºÙŠØ± Ù…ØªØ§Ø­", ephemeral=True)
            return
        
        await interaction.response.send_modal(BidModal(self.auction_message_id))

# ==================== ğŸ”„ HELPER FUNCTIONS ====================

async def update_auction_message(auction: Auction):
    channel = bot.get_channel(auction.channel_id)
    if not channel:
        return
    
    try:
        msg = await channel.fetch_message(auction.message_id)
    except:
        return
    
    embed = discord.Embed(title="ğŸ”¥ Ø§Ù„Ù…Ø²Ø§Ø¯ Ù…Ø´ØªØ¹Ù„ ğŸ”¥", color=0x9b59b6)
    embed.add_field(name="ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ", value=f"**{fmt_amount(auction.current_price)}**", inline=True)
    
    bidder_text = f"<@{auction.highest_bidder}>" if auction.highest_bidder else "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
    embed.add_field(name="ğŸ‘‘ Ø£Ø¹Ù„Ù‰ Ù…Ø²Ø§ÙŠØ¯", value=bidder_text, inline=True)
    
    seconds_left = max(0, int(auction.end_time - asyncio.get_event_loop().time()))
    mins = seconds_left // 60
    secs = seconds_left % 60
    time_text = f"{mins}Ø¯ {secs}Ø«" if mins > 0 else f"{secs}Ø«"
    embed.add_field(name="â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ", value=time_text, inline=False)
    
    embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
    
    view = AuctionView(auction.message_id)
    await msg.edit(embed=embed, view=view)

async def handle_auction_end(message_id: int, end_time: float):
    now = asyncio.get_event_loop().time()
    wait = end_time - now
    
    if wait > 0:
        await asyncio.sleep(wait)
    
    auction = AUCTIONS.get(message_id)
    if not auction or auction.ended:
        return
    
    auction.ended = True
    
    channel = bot.get_channel(auction.channel_id)
    if channel:
        try:
            msg = await channel.fetch_message(auction.message_id)
            embed = discord.Embed(title="ğŸ† Ø§Ù†ØªÙ‡Ù‰ Ø§Ù„Ù…Ø²Ø§Ø¯ ğŸ†", color=0x95a5a6)
            
            winner_text = f"<@{auction.highest_bidder}>" if auction.highest_bidder else "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¨ÙŠØ¹"
            embed.add_field(name="ğŸ† Ø§Ù„ÙØ§Ø¦Ø²", value=winner_text, inline=True)
            embed.add_field(name="ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ", value=f"**{fmt_amount(auction.current_price)}**", inline=True)
            embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
            
            await msg.edit(embed=embed, view=None)
        except:
            pass
    
    try:
        await db.end_auction(auction.db_id, auction.highest_bidder, auction.current_price)
    except Exception as e:
        logger.error(f"Error ending auction in DB: {e}")
    
    await asyncio.sleep(5)
    AUCTIONS.pop(message_id, None)

# ==================== ğŸ“ SLASH COMMANDS ====================

@tree.command(name="Ù…Ø²Ø§Ø¯", description="Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø²Ø§Ø¯ Ø¬Ø¯ÙŠØ¯ (Ø¥Ø¯Ø§Ø±Ø© ÙÙ‚Ø·)")
@app_commands.describe(
    start="Ø³Ø¹Ø± Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ù…Ø«Ø§Ù„: 500k Ø£Ùˆ 1m)",
    min_inc="Ø£Ù‚Ù„ Ø²ÙŠØ§Ø¯Ø© (Ù…Ø«Ø§Ù„: 50k)",
    duration="Ù…Ø¯Ø© Ø§Ù„Ù…Ø²Ø§Ø¯ Ø¨Ø§Ù„Ø¯Ù‚Ø§Ø¦Ù‚"
)
async def cmd_create_auction(
    interaction: discord.Interaction,
    start: str,
    min_inc: str,
    duration: int
):
    await interaction.response.defer(ephemeral=True)
    
    if not interaction.user.guild_permissions.manage_guild:
        await interaction.followup.send("âŒ ØªØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø³ÙŠØ±ÙØ±", ephemeral=True)
        return
    
    start_price = parse_amount(start)
    min_increase = parse_amount(min_inc)
    
    if start_price <= 0 or min_increase <= 0 or duration <= 0:
        await interaction.followup.send("âŒ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª ØºÙŠØ± ØµØ­ÙŠØ­Ø©", ephemeral=True)
        return
    
    embed = discord.Embed(title="ğŸ”¥ Ø§Ù„Ù…Ø²Ø§Ø¯ Ù…Ø´ØªØ¹Ù„ ğŸ”¥", color=0x9b59b6)
    embed.add_field(name="ğŸ’° Ø§Ù„Ø³Ø¹Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ", value=f"**{fmt_amount(start_price)}**", inline=True)
    embed.add_field(name="ğŸ‘‘ Ø£Ø¹Ù„Ù‰ Ù…Ø²Ø§ÙŠØ¯", value="Ù„Ø§ ÙŠÙˆØ¬Ø¯", inline=True)
    embed.add_field(name="â³ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ", value=f"{duration}Ø¯", inline=False)
    embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
    
    view = AuctionView(-1)
    msg = await interaction.channel.send(embed=embed, view=view)
    
    started_at = datetime.now(timezone.utc)
    end_time_dt = started_at + timedelta(minutes=duration)
    
    try:
        auction_db_id = await db.insert_auction(
            interaction.guild_id,
            interaction.channel_id,
            msg.id,
            start_price,
            start_price,
            min_increase,
            interaction.user.id,
            started_at.isoformat(),
            end_time_dt.isoformat()
        )
    except Exception as e:
        logger.error(f"Error creating auction in DB: {e}")
        auction_db_id = None
    
    auction = Auction(
        guild_id=interaction.guild_id,
        channel_id=interaction.channel_id,
        message_id=msg.id,
        db_id=auction_db_id,
        start_price=start_price,
        min_increase=min_increase,
        end_time=asyncio.get_event_loop().time() + duration * 60,
        created_by=interaction.user.id
    )
    
    AUCTIONS[msg.id] = auction
    view.auction_message_id = msg.id
    await msg.edit(view=view)
    
    asyncio.create_task(handle_auction_end(msg.id, auction.end_time))
    
    await interaction.followup.send(f"âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø²Ø§Ø¯ Ø¨Ù†Ø¬Ø§Ø­!", ephemeral=True)

@tree.command(name="Ø¥Ù„ØºØ§Ø¡_Ù…Ø²Ø§Ø¯", description="Ø¥Ù„ØºØ§Ø¡ Ù…Ø²Ø§Ø¯ Ù†Ø´Ø· (Ø¥Ø¯Ø§Ø±Ø© ÙÙ‚Ø·)")
@app_commands.describe(message_id="ID Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ø²Ø§Ø¯")
async def cmd_cancel_auction(interaction: discord.Interaction, message_id: str):
    await interaction.response.defer(ephemeral=True)
    
    if not interaction.user.guild_permissions.manage_guild:
        await interaction.followup.send("âŒ ØªØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¥Ø¯Ø§Ø±Ø©", ephemeral=True)
        return
    
    try:
        msg_id = int(message_id)
    except:
        await interaction.followup.send("âŒ ID Ø§Ù„Ø±Ø³Ø§Ù„Ø© ØºÙŠØ± ØµØ­ÙŠØ­", ephemeral=True)
        return
    
    auction = AUCTIONS.get(msg_id)
    if not auction:
        await interaction.followup.send("âŒ Ù„Ù… Ø£Ø¬Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø²Ø§Ø¯", ephemeral=True)
        return
    
    if auction.ended or auction.cancelled:
        await interaction.followup.send("âŒ Ø§Ù„Ù…Ø²Ø§Ø¯ Ù…Ù†ØªÙ‡ÙŠ Ø£Ùˆ Ù…Ù„ØºÙŠ Ø¨Ø§Ù„ÙØ¹Ù„", ephemeral=True)
        return
    
    auction.cancelled = True
    auction.ended = True
    
    channel = bot.get_channel(auction.channel_id)
    try:
        msg = await channel.fetch_message(auction.message_id)
        embed = discord.Embed(title="ğŸš« ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø²Ø§Ø¯", color=0xe74c3c)
        embed.add_field(name="Ø§Ù„Ø³Ø¨Ø¨", value="ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡ Ù…Ù† Ù‚Ø¨Ù„ Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©", inline=False)
        
        if auction.highest_bidder:
            embed.add_field(name="Ø¢Ø®Ø± Ù…Ø²Ø§ÙŠØ¯", value=f"<@{auction.highest_bidder}>", inline=True)
            embed.add_field(name="Ø¢Ø®Ø± Ø³Ø¹Ø±", value=f"**{fmt_amount(auction.current_price)}**", inline=True)
        
        embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
        await msg.edit(embed=embed, view=None)
    except Exception as e:
        logger.error(f"Error updating cancelled auction: {e}")
    
    try:
        await db.cancel_auction(auction.db_id)
    except Exception as e:
        logger.error(f"Error cancelling auction in DB: {e}")
    
    AUCTIONS.pop(msg_id, None)
    
    await interaction.followup.send("âœ… ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø²Ø§Ø¯ Ø¨Ù†Ø¬Ø§Ø­", ephemeral=True)

@tree.command(name="Ø³Ø¬Ù„_Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª", description="Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©")
@app_commands.describe(limit="Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª (Ø§ÙØªØ±Ø§Ø¶ÙŠ: 10)")
async def cmd_auction_history(interaction: discord.Interaction, limit: int = 10):
    await interaction.response.defer(ephemeral=True)
    
    if limit < 1 or limit > 50:
        await interaction.followup.send("âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ 1 ÙˆØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 50", ephemeral=True)
        return
    
    try:
        history = await db.get_auction_history(interaction.guild_id, limit)
        
        if not history:
            await interaction.followup.send("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø²Ø§Ø¯Ø§Øª Ø³Ø§Ø¨Ù‚Ø©", ephemeral=True)
            return
        
        embed = discord.Embed(
            title="ğŸ“š Ø³Ø¬Ù„ Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª",
            description=f"Ø¢Ø®Ø± {len(history)} Ù…Ø²Ø§Ø¯",
            color=0x3498db
        )
        
        for i, auction_data in enumerate(history, start=1):
            auction_id = auction_data.get('id')
            started_at = auction_data.get('started_at')
            winner_id = auction_data.get('winner_id')
            final_price = auction_data.get('current_price')
            cancelled = auction_data.get('cancelled', False)
            
            if isinstance(started_at, str):
                started_at = datetime.fromisoformat(started_at.replace('Z', '+00:00'))
            date_str = started_at.strftime("%Y-%m-%d %H:%M") if started_at else "N/A"
            
            if cancelled:
                status = "ğŸš« Ù…Ù„ØºÙŠ"
                winner_str = "ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡"
            elif winner_id:
                status = "âœ… Ù…ÙƒØªÙ…Ù„"
                winner_str = f"<@{winner_id}>"
            else:
                status = "âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¨ÙŠØ¹"
                winner_str = "Ù„Ø§ ÙŠÙˆØ¬Ø¯"
            
            value_text = f"**Ø§Ù„ØªØ§Ø±ÙŠØ®:** {date_str}\\n**Ø§Ù„Ø­Ø§Ù„Ø©:** {status}\\n**Ø§Ù„ÙØ§Ø¦Ø²:** {winner_str}\\n**Ø§Ù„Ø³Ø¹Ø±:** {fmt_amount(final_price or 0)}"
            
            embed.add_field(name=f"#{auction_id}", value=value_text, inline=False)
        
        embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
        await interaction.followup.send(embed=embed, ephemeral=True)
        
    except Exception as e:
        logger.error(f"Error fetching history: {e}")
        await interaction.followup.send("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø¬Ù„Ø¨ Ø§Ù„Ø³Ø¬Ù„", ephemeral=True)

@tree.command(name="ØªØµØ¯ÙŠØ±_Ù…Ø²Ø§Ø¯Ø§Øª", description="ØªØµØ¯ÙŠØ± Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª ÙƒÙ…Ù„Ù CSV (Ø¥Ø¯Ø§Ø±Ø© ÙÙ‚Ø·)")
@app_commands.describe(limit="Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª (Ø§ÙØªØ±Ø§Ø¶ÙŠ: 100)")
async def cmd_export_auctions(interaction: discord.Interaction, limit: int = 100):
    await interaction.response.defer(ephemeral=True)
    
    if not interaction.user.guild_permissions.manage_guild:
        await interaction.followup.send("âŒ ØªØ­ØªØ§Ø¬ ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¥Ø¯Ø§Ø±Ø©", ephemeral=True)
        return
    
    if limit < 1 or limit > 500:
        await interaction.followup.send("âŒ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰ 1 ÙˆØ§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ 500", ephemeral=True)
        return
    
    try:
        auctions = await db.get_auction_history(interaction.guild_id, limit)
        
        if not auctions:
            await interaction.followup.send("ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ù„Ù„ØªØµØ¯ÙŠØ±", ephemeral=True)
            return
        
        output = StringIO()
        writer = csv.writer(output)
        
        writer.writerow([
            'Auction ID', 'Started At', 'Ended At', 'Duration (min)',
            'Start Price', 'Final Price', 'Winner ID', 'Winner Name',
            'Creator ID', 'Total Bids', 'Status'
        ])
        
        for auction_data in auctions:
            auction_id = auction_data.get('id')
            started_at = auction_data.get('started_at')
            ended_at = auction_data.get('ended_at')
            start_price = auction_data.get('start_price', 0)
            final_price = auction_data.get('current_price', 0)
            winner_id = auction_data.get('winner_id')
            creator_id = auction_data.get('created_by')
            cancelled = auction_data.get('cancelled', False)
            
            duration = "N/A"
            if started_at and ended_at:
                if isinstance(started_at, str):
                    started_at = datetime.fromisoformat(started_at.replace('Z', '+00:00'))
                if isinstance(ended_at, str):
                    ended_at = datetime.fromisoformat(ended_at.replace('Z', '+00:00'))
                duration_delta = ended_at - started_at
                duration = round(duration_delta.total_seconds() / 60, 2)
            
            winner_username = "N/A"
            if winner_id:
                try:
                    winner = await bot.fetch_user(winner_id)
                    winner_username = str(winner)
                except:
                    winner_username = f"User#{winner_id}"
            
            bids = await db.get_bids_for_auction(auction_id)
            total_bids = len(bids)
            
            status = "Cancelled" if cancelled else ("Completed" if winner_id else "No Sale")
            
            writer.writerow([
                auction_id,
                started_at.isoformat() if started_at else "N/A",
                ended_at.isoformat() if ended_at else "N/A",
                duration,
                start_price,
                final_price,
                winner_id or "N/A",
                winner_username,
                creator_id or "N/A",
                total_bids,
                status
            ])
        
        output.seek(0)
        filename = f"auctions_{interaction.guild.id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv"
        file = discord.File(fp=output, filename=filename)
        
        await interaction.followup.send(
            f"âœ… ØªÙ… ØªØµØ¯ÙŠØ± {len(auctions)} Ù…Ø²Ø§Ø¯",
            file=file,
            ephemeral=True
        )
        
    except Exception as e:
        logger.error(f"Error exporting auctions: {e}")
        await interaction.followup.send("âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªØµØ¯ÙŠØ±", ephemeral=True)

# ==================== ğŸ¯ EVENTS ====================

@bot.event
async def on_ready():
    try:
        logger.info("=" * 60)
        logger.info("ğŸš€ STARTING AUCTIONBOT...")
        logger.info("=" * 60)
        
        logger.info("ğŸ“Š Connecting to database...")
        await db.init_pool(DATABASE_URL)
        await db.create_tables()
        logger.info("âœ… Database connected successfully!")
        
        if ALLOWED_GUILD_ID:
            logger.info(f"ğŸ”’ Guild Lock ENABLED (ID: {ALLOWED_GUILD_ID})")
            
            guilds_to_leave = []
            for guild in bot.guilds:
                if guild.id != ALLOWED_GUILD_ID:
                    logger.warning(f"ğŸš« Unauthorized guild detected: {guild.name} (ID: {guild.id})")
                    guilds_to_leave.append(guild)
            
            for guild in guilds_to_leave:
                try:
                    logger.info(f"ğŸšª Leaving: {guild.name}")
                    await guild.leave()
                    logger.info(f"âœ… Left successfully")
                except Exception as e:
                    logger.error(f"âŒ Error leaving guild: {e}")
        else:
            logger.warning("âš ï¸ Guild Lock DISABLED - Bot will work in any server")
        
        logger.info("ğŸ”„ Syncing commands...")
        await tree.sync()
        logger.info("âœ… Commands synced!")
        
        logger.info("=" * 60)
        logger.info("ğŸ‰ BOT IS READY AND OPERATIONAL!")
        logger.info(f"ğŸ‘¤ Logged in as: {bot.user}")
        logger.info(f"ğŸ†” Bot ID: {bot.user.id}")
        logger.info(f"ğŸŒ Servers: {len(bot.guilds)}")
        logger.info(f"ğŸ“Š Database: Connected")
        if ALLOWED_GUILD_ID:
            logger.info(f"ğŸ”’ Guild Lock: ACTIVE")
        logger.info("=" * 60)
        logger.info("")
        logger.info("âœ…âœ…âœ… Ù†Ø¬Ø­Ù†Ø§! Ø§Ù„Ø¨ÙˆØª Ø´ØºØ§Ù„ 100% âœ…âœ…âœ…")
        logger.info("")
        logger.info("=" * 60)
        
    except Exception as e:
        logger.critical("=" * 60)
        logger.critical("âŒâŒâŒ ÙØ´Ù„Ù†Ø§! Ø­Ø¯Ø« Ø®Ø·Ø£ âŒâŒâŒ")
        logger.critical(f"Error: {e}")
        logger.critical(traceback.format_exc())
        logger.critical("=" * 60)

@bot.event
async def on_guild_join(guild: discord.Guild):
    if ALLOWED_GUILD_ID and guild.id != ALLOWED_GUILD_ID:
        logger.warning(f"ğŸš« Attempted join to unauthorized guild: {guild.name}")
        
        try:
            for channel in guild.text_channels:
                if channel.permissions_for(guild.me).send_messages:
                    embed = discord.Embed(
                        title="ğŸš« ØºÙŠØ± Ù…ØµØ±Ø­",
                        description="Ø¹Ø°Ø±Ø§Ù‹ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨ÙˆØª Ø®Ø§Øµ ÙˆÙ…Ù‚ØªØµØ± Ø¹Ù„Ù‰ Ø³ÙŠØ±ÙØ± Ù…Ø¹ÙŠÙ†.",
                        color=0xe74c3c
                    )
                    embed.set_footer(text="Ø§Ù„Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¬Ù†ÙˆØ¨ÙŠØ© | Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ø²Ø§Ø¯Ø§Øª")
                    await channel.send(embed=embed)
                    break
        except:
            pass
        
        await guild.leave()
        logger.info(f"âœ… Left unauthorized guild: {guild.name}")

@bot.event
async def on_error(event: str, *args, **kwargs):
    logger.error(f"âŒ Error in {event}:")
    logger.error(traceback.format_exc())

# ==================== ğŸš€ RUN BOT ====================

async def run_bot():
    max_retries = 5
    retry_count = 0
    
    while retry_count < max_retries:
        try:
            logger.info(f"ğŸ”Œ Connecting to Discord... (Attempt {retry_count + 1}/{max_retries})")
            
            async with bot:
                await bot.start(TOKEN)
                
        except discord.LoginFailure:
            logger.critical("=" * 60)
            logger.critical("âŒâŒâŒ ÙØ´Ù„Ù†Ø§! Discord Token Ø®Ø§Ø·Ø¦ âŒâŒâŒ")
            logger.critical("=" * 60)
            logger.critical("ğŸ’¡ ØªØ­Ù‚Ù‚ Ù…Ù† DISCORD_TOKEN ÙÙŠ Railway")
            break
            
        except discord.HTTPException as e:
            retry_count += 1
            
            if e.status == 429:
                wait_time = 30
                logger.warning(f"âš ï¸ Rate limited! Waiting {wait_time}s...")
                await asyncio.sleep(wait_time)
            else:
                wait_time = 10 * retry_count
                logger.error(f"âŒ HTTP Error {e.status}: {e}")
                logger.info(f"â³ Retrying in {wait_time}s...")
                await asyncio.sleep(wait_time)
                
        except Exception as e:
            retry_count += 1
            logger.error(f"âŒ Error: {type(e).__name__}: {e}")
            logger.error(traceback.format_exc())
            
            if retry_count < max_retries:
                wait_time = 10 * retry_count
                logger.info(f"â³ Retrying in {wait_time}s...")
                await asyncio.sleep(wait_time)
            else:
                logger.critical("=" * 60)
                logger.critical("âŒâŒâŒ ÙØ´Ù„Ù†Ø§! ÙˆØµÙ„Ù†Ø§ Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª âŒâŒâŒ")
                logger.critical("=" * 60)
                break
    
    logger.info("ğŸ›‘ Bot shutdown")

# ==================== ğŸ¬ MAIN ====================

if __name__ == "__main__":
    try:
        if len(TOKEN) < 50:
            print("=" * 60)
            print("âŒâŒâŒ ÙØ´Ù„Ù†Ø§! DISCORD_TOKEN ØºÙŠØ± ØµØ­ÙŠØ­ âŒâŒâŒ")
            print("=" * 60)
            print(f"Token length: {len(TOKEN)}")
            print("ğŸ’¡ ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø¶Ø§ÙØ© Token ØµØ­ÙŠØ­ ÙÙŠ Railway")
            sys.exit(1)
        
        asyncio.run(run_bot())
        
    except KeyboardInterrupt:
        logger.info("âš ï¸ Bot stopped by user")
    except Exception as e:
        logger.critical("=" * 60)
        logger.critical("âŒâŒâŒ ÙØ´Ù„Ù†Ø§! Ø®Ø·Ø£ ÙØ§Ø¯Ø­ âŒâŒâŒ")
        logger.critical(f"Error: {e}")
        logger.critical(traceback.format_exc())
        logger.critical("=" * 60)
        sys.exit(1)


# ====================================================================
# END OF FILE: bot.py
# ====================================================================
